% Generated by roxygen2 (4.1.1.9000): do not edit by hand
% Please edit documentation in R/Simulations.R
\name{run.sims}
\alias{run.sims}
\title{Run a simulation study}
\usage{
run.sims(sim.function, param.matrix, num.reps,
  sim.directory = "sim_directory", prep.function = NULL, verbose = FALSE)
}
\arguments{
\item{sim.function}{A function to run a single simulation.}

\item{num.reps}{The number of replicate simulations for each
parameter combination.}

\item{sim.directory}{The local directory to store the simulation
results.}

\item{prep.function}{A function to be run before each new parameter
combination is started.}

\item{verbose}{If information about what parameter combination and
replicate number is about to be run.}

\item{params}{A data frame of parameter values. The order
of the columns must match the order of the arguments to the
sim.function.}
}
\description{
Conduct a simulation study where we have a matrix
of parameter values that we are interested. For
each row in the parameter matrix, the simulation
function is called num.reps times and the output
of each run is saved to the simulation directory.
}
\details{
The simulation can be re-run with higher num.reps and
the original simulations (still stored in the simulation
directory) will be used and only the additional replications
will be run.  Likewise, if the simulation is interupted
(say a power outage...), the simulation can be re-started
and the previous iterations will not be lost.
}
\examples{
# Simulation is creating data and fitting
# a regression model to estimate a slope.
Sim.Function <- function(N, alpha, beta, sigma){
  x <- runif(N, 0, 10)
  y <- alpha + beta*x + rnorm(N, 0, sigma)
  model <- lm(y~x)
  return(model)
}

# Create a matrix where each row represents a set of parameters
Params <- expand.grid(N=20, alpha=0, beta=c(0,1), sigma=c(.2, 1))

# Run the simulations.
run.sims(Sim.Function, Params, num.reps=10)

# Now that the simulations are run, we want to analyze
# them.  Create a function to be applied to each simulation
# that results in a single row.  Those rows will be concatenated
# together into a large data frame that summarizes the simulation.

# Because the output of the Sim.Function was a linear model output,
# that is the input for this function
Summary.Function <- function(model, params){
  beta.hat <- coef(model)[2]
  beta.lwr <- confint(model)[2,1]
  beta.upr <- confint(model)[2,2]
  return( data.frame(beta=beta.hat, lwr=beta.lwr, upr=beta.upr))
}

Sims <- summarize.sims(Summary.Function, Params)
}

